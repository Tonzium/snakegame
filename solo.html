<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snake Game</title>
  <style>
    :root {
      --btn-size: 105px;       /* Larger buttons */
      --btn-gap: 18px;
      --accent: #1e90ff;
    }

    body {
      text-align: center;
      font-family: Arial, sans-serif;
      color: white;
      background-color: black;
      margin: 0;
      padding: 16px 12px calc(env(safe-area-inset-bottom) + 16px);
      -webkit-user-select: none;
      user-select: none;
    }

    canvas {
      border: 1px solid #555;
      background-color: #000;
      display: block;
      margin: 0 auto 18px auto;
      max-width: 95vw;
      height: auto;
      touch-action: none;
    }

    /* On-screen controls container */
    .controls {
      width: 100%;
      max-width: 450px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: auto auto auto;
      gap: var(--btn-gap);
      justify-items: center;
      align-items: center;
      touch-action: manipulation;
      position: relative;
    }

    /* Layout like D-pad */
    .up    { grid-column: 2; grid-row: 1; }
    .left  { grid-column: 1; grid-row: 2; }
    .right { grid-column: 3; grid-row: 2; }
    .down  { grid-column: 2; grid-row: 3; margin-top: 8px; } /* Lower down button */

    .ctrl-btn {
      width: var(--btn-size);
      height: var(--btn-size);
      border-radius: 18px;
      border: 2px solid #444;
      background: #111;
      color: #fff;
      font-size: 38px;
      font-weight: bold;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 14px rgba(0,0,0,0.4);
      transition: transform 0.02s ease, background 0.15s ease, border-color 0.15s ease;
    }

    .ctrl-btn:active {
      transform: scale(0.97);
      background: #0d0d0d;
      border-color: var(--accent);
    }

    .ctrl-btn:focus-visible {
      outline: 3px solid var(--accent);
      outline-offset: 2px;
    }

    h2 { margin: 10px 0 12px; }

    .scores {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-bottom: 8px;
      color: #ddd;
      font-size: 14px;
      opacity: .9;
    }
  </style>
</head>
<body>
  <h2>Snake Game</h2>
  <div class="scores" id="scores" aria-live="polite"></div>

  <canvas id="game" width="600" height="600" aria-label="Snake game board"></canvas>

  <!-- On-screen mobile controls -->
  <div class="controls" aria-label="Directional controls">
    <button class="ctrl-btn up"    id="btnUp"    aria-label="Move up">â–²</button>
    <button class="ctrl-btn left"  id="btnLeft"  aria-label="Move left">â—€</button>
    <button class="ctrl-btn right" id="btnRight" aria-label="Move right">â–¶</button>
    <button class="ctrl-btn down"  id="btnDown"  aria-label="Move down">â–¼</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const GRID_SIZE = 30;
    const CELL_SIZE = canvas.width / GRID_SIZE;

    const DIRECTIONS = {
      'ArrowUp': [0, -1],
      'ArrowDown': [0, 1],
      'ArrowLeft': [-1, 0],
      'ArrowRight': [1, 0],
      'w': [0, -1],
      's': [0, 1],
      'a': [-1, 0],
      'd': [1, 0]
    };

    let snake = {
      body: [{x: 5, y: 15}, {x: 4, y: 15}, {x: 3, y: 15}],
      dir: {x: 1, y: 0},
      grow: false,
      color: 'white',
      score: 0
    };

    let aiSnake = {
      body: [{x: 24, y: 15}, {x: 25, y: 15}, {x: 26, y: 15}],
      dir: {x: -1, y: 0},
      grow: false,
      color: 'blue',
      score: 0
    };

    let reward = {x: 10, y: 10};
    let gameOver = false;

    function randomReward() {
      while (true) {
        let pos = {
          x: Math.floor(Math.random() * GRID_SIZE),
          y: Math.floor(Math.random() * GRID_SIZE)
        };
        if (!snake.body.some(p => p.x === pos.x && p.y === pos.y) &&
            !aiSnake.body.some(p => p.x === pos.x && p.y === pos.y))
          return pos;
      }
    }

    function changeDir(keyLike) {
      const newDir = DIRECTIONS[keyLike];
      if (!newDir || gameOver) return;
      if (snake.dir.x + newDir[0] !== 0 || snake.dir.y + newDir[1] !== 0) {
        snake.dir = { x: newDir[0], y: newDir[1] };
      }
    }

    document.addEventListener('keydown', e => changeDir(e.key));

    const bindBtn = (el, keyLike) => {
      ['pointerdown','click'].forEach(evt =>
        el.addEventListener(evt, ev => { ev.preventDefault(); changeDir(keyLike); }, { passive: false })
      );
    };
    bindBtn(document.getElementById('btnUp'), 'ArrowUp');
    bindBtn(document.getElementById('btnDown'), 'ArrowDown');
    bindBtn(document.getElementById('btnLeft'), 'ArrowLeft');
    bindBtn(document.getElementById('btnRight'), 'ArrowRight');

    function moveSnake(s) {
      const newHead = {x: s.body[0].x + s.dir.x, y: s.body[0].y + s.dir.y};
      if (!s.grow) s.body.pop(); else s.grow = false;
      s.body.unshift(newHead);
    }

    function collision(s) {
      const head = s.body[0];
      return (
        head.x < 0 || head.x >= GRID_SIZE ||
        head.y < 0 || head.y >= GRID_SIZE ||
        s.body.slice(1).some(p => p.x === head.x && p.y === head.y)
      );
    }

    function aiChooseDirection() {
      const head = aiSnake.body[0];
      let bestDir = aiSnake.dir;
      let minDist = Infinity;

      [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].forEach(d => {
        const next = {x: head.x + d.x, y: head.y + d.y};
        if (aiSnake.body.some(p => p.x === next.x && p.y === next.y) ||
            snake.body.some(p => p.x === next.x && p.y === next.y) ||
            next.x < 0 || next.x >= GRID_SIZE || next.y < 0 || next.y >= GRID_SIZE)
          return;
        const dist = Math.abs(next.x - reward.x) + Math.abs(next.y - reward.y);
        if (dist < minDist) {
          minDist = dist;
          bestDir = d;
        }
      });
      aiSnake.dir = bestDir;
    }

    function drawCell(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    function drawBorder() {
      ctx.strokeStyle = 'grey';
      ctx.lineWidth = 2;
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBorder();
      drawCell(reward.x, reward.y, 'lightgreen');
      snake.body.forEach(p => drawCell(p.x, p.y, snake.color));
      aiSnake.body.forEach(p => drawCell(p.x, p.y, aiSnake.color));

      ctx.fillStyle = 'white';
      ctx.font = "20px Arial";
      ctx.fillText('Player: ' + snake.score, 10, 20);
      const aiLabel = 'AI: ' + aiSnake.score;
      const metrics = ctx.measureText(aiLabel);
      ctx.fillText(aiLabel, canvas.width - metrics.width - 10, 20);
      document.getElementById('scores').textContent =
        `Player: ${snake.score} | AI: ${aiSnake.score}`;
    }

    function endGame(message) {
      if (!gameOver) {
        gameOver = true;
        alert(`${message}\nFinal Score: You (${snake.score}) - AI (${aiSnake.score})`);
        document.location.reload();
      }
    }

    function update() {
      if (gameOver) return;
      moveSnake(snake);
      moveSnake(aiSnake);

      if (collision(snake)) endGame("You Lose! ðŸ˜¢");
      if (collision(aiSnake)) endGame("You Win! ðŸ†");
      if (snake.body[0].x === aiSnake.body[0].x && snake.body[0].y === aiSnake.body[0].y)
        endGame("It's a Tie! ðŸ¤");
      if (aiSnake.body.some(p => p.x === snake.body[0].x && p.y === snake.body[0].y))
        endGame("You Lose! ðŸ˜¢");

      if (snake.body[0].x === reward.x && snake.body[0].y === reward.y) {
        snake.grow = true; snake.score++; reward = randomReward();
      }
      if (aiSnake.body[0].x === reward.x && aiSnake.body[0].y === reward.y) {
        aiSnake.grow = true; aiSnake.score++; reward = randomReward();
      }

      aiChooseDirection();
      draw();
    }

    setInterval(update, 100);
  </script>
</body>
</html>
